module Main where

import Data.List (isPrefixOf, intersperse)

main :: IO ()
main = do
    src <- fmap lines $ readFile "Eigenvector.lidr"

    let (_, prose, code) = generateProse (src, [initialProse], [initialCode]) 

    writeFile "Eigenvector.idr" $ (unlines . reverse) code
    writeFile "eigenvectors-in-idris.md" $ (unlines . reverse) prose

-- Make sure to modify the literate source code, not the generated markdown
-- or idris code.
initialProse :: String
initialProse = "[comment]: # (" ++ doNotModify ++ ")"

initialCode :: String
initialCode = "||| " ++ doNotModify

doNotModify :: String
doNotModify = 
    "DO NOT MODIFY: This file is automatically generated from Eigenvector.lidr."

-- The literate idris source file contains two types of content: code and prose.
generateProse :: ([String], [String], [String]) 
    -> ([String], [String], [String])
generateProse (original, prose, code) = case original of
    [] -> (original, prose, code) -- base case
    (line : lines) -> 
        if "> --- Code hidden from blog post. ---" `isPrefixOf` line
        then generateHiddenCode (lines, prose, code)
        else if ">" `isPrefixOf` line
             then generateCode (original, "```idris" : prose, code)
             else generateProse (lines, line : prose, code)

-- If there's a full line of code, there's typically a > and a space before any 
-- code - but there are some lines where there's just a >. This handles both 
-- cases so that the resulting code always starts at the beginning of the line.
cleanupCode :: String -> String
cleanupCode line = case line of
    (c1 : (c2 : cs)) -> cs
    (c1 : cs)        -> cs
    _                -> line

generateCode :: ([String], [String], [String])
    -> ([String], [String], [String])
generateCode (original, prose, code) = case original of
    [] -> (original, prose, code)
    (line : lines) ->
        if ">" `isPrefixOf` line
        then generateCode (lines, tail line : prose, cleanupCode line : code)
        else generateProse (original, "```" : prose, "\n" : code)

-- Because this code is hidden from the blog post, there's no need to emit a 
-- closing ``` when we're done reading a code block.
generateHiddenCode :: ([String], [String], [String])
    -> ([String], [String], [String])
generateHiddenCode (original, prose, code) = case original of
    [] -> (original, prose, code)
    (line : lines) ->
        if ">" `isPrefixOf` line
        then generateHiddenCode (lines, prose, cleanupCode line : code)
        else generateProse (original, prose, "\n" : code)

